
def createListofItems(**kwargs):
    '''
    Creates a list of items from the provided kwargs. 
    The items are sorted using the keys.
    '''
    out_list = []
    for k, v in sorted(kwargs.items()):
        out_list.append(v)
    return out_list

def getElementFromList(inlist, idx, slc=None):
    '''
    For selecting a particular element or slice from a list
    within a nipype connect statement.
    If the slice is longer than the list, this returns the list
    '''
    if slc is None:
        outlist = inlist[idx]
    else:
        if slc == 0:
            outlist = inlist[idx:]
        else:
            outlist = inlist[idx:slc]
    return outlist

def getElementFromListofList(inlist, idx):
    '''
    For selecting a particular element or elements from a list of list.
    It returns a simple list containing elements selected by idx value or values.
    If providing a list of idx values, it should be same length as the non-empty inlist.
    '''
    # drop any empty list in inlist
    in_list = [l for l in inlist if l]
    if isinstance(idx, list):
        outlist = [l[i] for i, l in zip(idx, in_list)]
    else:
        outlist = [l[idx] for l in in_list]
    return outlist

def Gzip(in_file):
    '''
    gzip file
    '''
    import os.path as op
    import gzip
    import shutil as sh

    out_file = '{}.gz'.format(op.basename(in_file))
    with open(in_file, "rb") as in_f:
        with gzip.open(out_file, "wb") as out_f:
            sh.copyfileobj(in_f, out_f)

    return(op.abspath(out_file))

def saveToCsv(out_file, **kwargs):
    '''
    Save the dict as csv
    '''
    import os.path as op
    import pandas as pd
    
    dat = {}
    for k, v in kwargs.items():
        dat[k] = v if isinstance(v, list) else [v]

    df =  pd.DataFrame(dat)
    df.to_csv(out_file, index=False)

    return(op.abspath(out_file))

def toList(item):
    '''
    Put an item in a list
    '''
    return [item]

def getCropInfo(crop_dimensions, center, sh_version=False):
    '''
    Returns the values that we need to properly crop an image using ExtractROI from FSL.

    When sh_version=True, int() operation is used on center values, since this was how it was
    done when cropping was performed in shell scripts before nipype pipeline version.

    Thus, this option allows for replication of shell-script behaviour for UKB, for instance.
    '''
    import numpy as np
    import os.path as op

    x_size = crop_dimensions[0]
    y_size = crop_dimensions[1]
    z_size = crop_dimensions[2]

    if sh_version:
        x_min = int(int(center[0]) - x_size/2)
        y_min = int(int(center[1]) - y_size/2)
        z_min = int(int(center[2]) - z_size/2)

    else:
        x_min = int(center[0] - x_size/2)
        y_min = int(center[1] - y_size/2)
        z_min = int(center[2] - z_size/2)

    # also save them as a text file, in the order
    # x_min y_min z_min
    # x_size y_size z_size
    cropinfo = np.array([[x_min, y_min, z_min],[x_size, y_size, z_size]])
    out_file = op.abspath('crop_info.txt')
  
    np.savetxt(out_file, cropinfo, '%d')

    return (x_min, y_min, z_min), out_file

def readCropInfo(crop_info_txt):
    '''
    Fxn to get x_min, y_min, z_min from crop_info.txt generated by getCropInfo.
    '''
    import numpy as np
    cropinfo = np.loadtxt(crop_info_txt)
    x_min, y_min, z_min = cropinfo[0, :].astype(int)
    
    return (x_min, y_min, z_min)

def createOutputDir(sub, base, name, nodename, single_sub=False, mapnode=False, mapnode_length=None):
    import os.path as op
    if single_sub:
        out_dir = op.join(base, name, nodename)
    else:
        out_dir = op.join(base, name, '_subject_id_{}'.format(sub), nodename)

    if mapnode:
        out_dir_list = [op.join(out_dir, 'mapflow', '_{}{}'.format(nodename, i)) for i in range(mapnode_length)]
            
    return out_dir_list if mapnode else out_dir
